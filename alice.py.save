#!/usr/bin/env python3
"""
ITIS 6200/8200 - Secure Messaging Project (FIXED VERSION)
Alice's Terminal Program
"""

import hashlib
import hmac as hmac_lib
import secrets
import time
import json
import base64
from cryptography.hazmat.primitives.asymmetric import rsa, padding
from cryptography.hazmat.primitives import hashes, serialization
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.backends import default_backend

# ============================================================================
# TASK 1: DIGITAL SIGNATURE
# ============================================================================

class DigitalSignature:
    """Digital signature mechanism using RSA"""
    
    @staticmethod
    def generate_keys():
        """Generate RSA key pair (public and private keys)"""
        private_key = rsa.generate_private_key(
            public_exponent=65537,
            key_size=2048,
            backend=default_backend()
        )
        public_key = private_key.public_key()
        return private_key, public_key
    
    @staticmethod
    def sign(message, private_key):
        """Sign a message with private key"""
        if isinstance(message, str):
            message = message.encode()
        
        signature = private_key.sign(
            message,
            padding.PSS(
                mgf=padding.MGF1(hashes.SHA256()),
                salt_length=padding.PSS.MAX_LENGTH
            ),
            hashes.SHA256()
        )
        return signature
    
    @staticmethod
    def verify(message, signature, public_key):
        """Verify a signature with public key. Returns 1 if valid, 0 if invalid"""
        try:
            if isinstance(message, str):
                message = message.encode()
            
            public_key.verify(
                signature,
                message,
                padding.PSS(
                    mgf=padding.MGF1(hashes.SHA256()),
                    salt_length=padding.PSS.MAX_LENGTH
                ),
                hashes.SHA256()
            )
            return 1
        except:
            return 0

# ============================================================================
# TASK 2: DIFFIE-HELLMAN KEY EXCHANGE
# ============================================================================

class DiffieHellman:
    """Diffie-Hellman key exchange implementation"""
    
    def __init__(self):
        # Smaller but still secure prime for demonstration
        self.p = int("FFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD1"
                     "29024E088A67CC74020BBEA63B139B22514A08798E3404DD"
                     "EF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245"
                     "E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7ED"
                     "EE386BFB5A899FA5AE9F24117C4B1FE649286651ECE45B3D"
                     "C2007CB8A163BF0598DA48361C55D39A69163FA8FD24CF5F"
                     "83655D23DCA3AD961C62F356208552BB9ED529077096966D"
                     "670C354E4ABC9804F1746C08CA18217C32905E462E36CE3B"
                     "E39E772C180E86039B2783A2EC07A28FB5C55DF06F4C52C9"
                     "DE2BCBF6955817183995497CEA956AE515D2261898FA0510"
                     "15728E5A8AACAA68FFFFFFFFFFFFFFFF", 16)
        self.g = 2
        self.private_key = None
        self.public_value = None
        self.shared_secret = None
    
    def generate_private_key(self):
        """Generate a random private key"""
        self.private_key = secrets.randbelow(self.p - 2) + 1
        return self.private_key
    
    def compute_public_value(self):
        """Compute g^a mod p"""
        if self.private_key is None:
            self.generate_private_key()
        self.public_value = pow(self.g, self.private_key, self.p)
        return self.public_value
    
    def compute_shared_secret(self, other_public_value):
        """Compute g^ab mod p using received public value"""
        self.shared_secret = pow(other_public_value, self.private_key, self.p)
        return self.shared_secret

# ============================================================================
# TASK 3: KEY DERIVATION FUNCTION (KDF)
# ============================================================================

class KeyDerivation:
    """Key Derivation Function using iterated hashing"""
    
    @staticmethod
    def derive_key(shared_secret, iterations=10000):
        """Derive encryption key from shared secret"""
        if isinstance(shared_secret, int):
            # Convert large int to bytes properly
            byte_length = (shared_secret.bit_length() + 7) // 8
            shared_secret = shared_secret.to_bytes(byte_length, byteorder='big')
        elif isinstance(shared_secret, str):
            shared_secret = shared_secret.encode()
        
        key = shared_secret
        for i in range(iterations):
            key = hashlib.sha256(key).digest()
        
        return key

# ============================================================================
# TASK 4: PSEUDO-RANDOM NUMBER GENERATOR (PRNG)
# ============================================================================

class PRNG:
    """Pseudo-Random Number Generator"""
    
    def __init__(self, seed_value=None):
        self.state = None
        if seed_value is not None:
            self.seed(seed_value)
        else:
            self.seed(int(time.time() * 1000000))
    
    def seed(self, seed_value):
        """Initialize the internal state with a seed value"""
        if isinstance(seed_value, str):
            seed_value = int(hashlib.sha256(seed_value.encode()).hexdigest(), 16)
        self.state = seed_value % (2**256)
    
    def reseed(self, additional_entropy):
        """Add more randomness to the current state"""
        if isinstance(additional_entropy, str):
            additional_entropy = int(hashlib.sha256(additional_entropy.encode()).hexdigest(), 16)
        self.state = (self.state + additional_entropy) % (2**256)
    
    def generate(self, num_bytes=16):
        """Generate random bytes"""
        self.state = int(hashlib.sha256(str(self.state).encode()).hexdigest(), 16)
        byte_length = min(num_bytes, 32)
        return self.state.to_bytes(32, byteorder='big')[:byte_length]

# ============================================================================
# TASK 5: SECURE MESSAGE EXCHANGE
# ============================================================================

class SecureMessaging:
    """Authenticated Encryption for secure message exchange"""
    
    def __init__(self, encryption_key, prng):
        self.encryption_key = encryption_key
        self.prng = prng
    
    def sym_enc(self, plaintext, iv=None):
        """Symmetric encryption using AES-256 in CBC mode"""
        if isinstance(plaintext, str):
            plaintext = plaintext.encode()
        
        if iv is None:
            iv = self.prng.generate(16)
        
        padding_length = 16 - (len(plaintext) % 16)
        plaintext += bytes([padding_length] * padding_length)
        
        cipher = Cipher(
            algorithms.AES(self.encryption_key),
            modes.CBC(iv),
            backend=default_backend()
        )
        encryptor = cipher.encryptor()
        ciphertext = encryptor.update(plaintext) + encryptor.finalize()
        
        return ciphertext, iv
    
    def sym_dec(self, ciphertext, iv):
        """Symmetric decryption using AES-256 in CBC mode"""
        cipher = Cipher(
            algorithms.AES(self.encryption_key),
            modes.CBC(iv),
            backend=default_backend()
        )
        decryptor = cipher.decryptor()
        plaintext_padded = decryptor.update(ciphertext) + decryptor.finalize()
        
        padding_length = plaintext_padded[-1]
        plaintext = plaintext_padded[:-padding_length]
        
        return plaintext
    
    def compute_hmac(self, data):
        """Compute HMAC-SHA256"""
        h = hmac_lib.new(self.encryption_key, data, hashlib.sha256)
        return h.digest()
    
    def authenticated_encrypt(self, plaintext):
        """Encrypt-then-MAC authenticated encryption"""
        ciphertext, iv = self.sym_enc(plaintext)
        data_to_authenticate = iv + ciphertext
        hmac_tag = self.compute_hmac(data_to_authenticate)
        return iv, ciphertext, hmac_tag

# ============================================================================
# MAIN ALICE PROGRAM
# ============================================================================

def print_header(text):
    """Print a nice header"""
    print("\n" + "="*70)
    print(f"  {text}")
    print("="*70)

def main():
    print("\nüîê ALICE'S TERMINAL - Secure Messaging Project")
    print(f"‚è∞ Timestamp: {time.strftime('%Y-%m-%d %H:%M:%S')}")
    
    # TASK 1
    print_header("TASK 1: DIGITAL SIGNATURE")
    ds = DigitalSignature()
    alice_private_key, alice_public_key = ds.generate_keys()
    print("‚úì Alice's RSA key pair generated")
    
    alice_public_pem = alice_public_key.public_bytes(
        encoding=serialization.Encoding.PEM,
        format=serialization.PublicFormat.SubjectPublicKeyInfo
    )
    print("\nüìã Alice's Public Key:")
    print(alice_public_pem.decode())
    
    test_message = "Hello, this is Alice!"
    print(f"\nüß™ Testing signature with message: '{test_message}'")
    signature = ds.sign(test_message, alice_private_key)
    print(f"‚úì Signature created (length: {len(signature)} bytes)")
    result = ds.verify(test_message, signature, alice_public_key)
    print(f"‚úì Verification with Alice's public key: {result} (should be 1)")
    
    # TASK 2
    print_header("TASK 2: DIFFIE-HELLMAN KEY EXCHANGE")
    dh_alice = DiffieHellman()
    print(f"\nüìã Public parameters:")
    print(f"p (first 50 digits): {str(dh_alice.p)[:50]}...")
    print(f"g (generator): {dh_alice.g}")
    
    alice_private = dh_alice.generate_private_key()
    alice_public = dh_alice.compute_public_value()
    
    print(f"\nüîë Alice's private key (first 20 digits): {str(alice_private)[:20]}...")
    print(f"üì§ Alice's public value (first 50 digits): {str(alice_public)[:50]}...")
    
    alice_dh_signature = ds.sign(str(alice_public), alice_private_key)
    print(f"\n‚úì Alice signs her public value")
    
    # Create exchange package
    alice_package = {
        'public_value': str(alice_public),
        'signature': base64.b64encode(alice_dh_signature).decode(),
        'public_key': alice_public_pem.decode()
    }
    
    alice_package_str = json.dumps(alice_package, indent=2)
    
    print("\n" + "‚îÄ"*70)
    print("üì® COPY THIS ENTIRE BLOCK AND PASTE INTO BOB'S TERMINAL:")
    print("‚îÄ"*70)
    print(alice_package_str)
    print("‚îÄ"*70)
    
    print("\n‚è∏Ô∏è  Now go to Bob's terminal and paste the above block")
    print("üì• Then come back here and paste Bob's package:")
    bob_package_str = input()
    
    bob_package = json.loads(bob_package_str)
    bob_public = int(bob_package['public_value'])
    bob_dh_signature = base64.b64decode(bob_package['signature'])
    bob_public_key_pem = bob_package['public_key'].encode()
    bob_public_key = serialization.load_pem_public_key(bob_public_key_pem, backend=default_backend())
    
    verification_result = ds.verify(str(bob_public), bob_dh_signature, bob_public_key)
    print(f"\n‚úì Alice verifies Bob's signature: {verification_result} (should be 1)")
    
    if verification_result == 1:
        shared_secret = dh_alice.compute_shared_secret(bob_public)
        print(f"\nüîê Shared secret computed (first 50 digits): {str(shared_secret)[:50]}...")
    else:
        print("‚ùå Signature verification failed!")
        return
    
    # TASK 3
    print_header("TASK 3: KEY DERIVATION FUNCTION")
    iterations = 10000
    encryption_key = KeyDerivation.derive_key(shared_secret, iterations)
    print(f"‚úì Derived encryption key using {iterations} iterations of SHA-256")
    print(f"üîë Encryption key (hex): {encryption_key.hex()}")
    
    # TASK 4
    print_header("TASK 4: PSEUDO-RANDOM NUMBER GENERATOR")
    prng = PRNG()
    print("‚úì PRNG initialized")
    print("\nüìä Random sequence (5 numbers):")
    for i in range(5):
        rand_bytes = prng.generate(8)
        rand_int = int.from_bytes(rand_bytes, byteorder='big')
        print(f"  {i+1}. {rand_int}")
    
    # TASK 5
    print_header("TASK 5: SECURE MESSAGE EXCHANGE")
    msg_prng = PRNG(int(time.time() * 1000000))
    secure_msg = SecureMessaging(encryption_key, msg_prng)
    
    message = input("\nüìù Enter message to send to Bob: ")
    print(f"\nüì§ Encrypting message: '{message}'")
    
    iv, ciphertext, hmac_tag = secure_msg.authenticated_encrypt(message)
    
    print(f"\n‚úì Encryption complete")
    print(f"  ‚Ä¢ IV (hex): {iv.hex()}")
    print(f"  ‚Ä¢ Ciphertext (hex): {ciphertext.hex()}")
    print(f"  ‚Ä¢ HMAC (hex): {hmac_tag.hex()}")
    
    message_package = {
        'iv': iv.hex(),
        'ciphertext': ciphertext.hex(),
        'hmac': hmac_tag.hex()
    }
    
    message_package_str = json.dumps(message_package, indent=2)
    
    print("\n" + "‚îÄ"*70)
    print("üì® COPY THIS AND PASTE INTO BOB'S TERMINAL:")
    print("‚îÄ"*70)
    print(message_package_str)
    print("‚îÄ"*70)
    
    print("\n‚úÖ Project completed successfully!")
    print(f"‚è∞ End timestamp: {time.strftime('%Y-%m-%d %H:%M:%S')}")

if __name__ == "__main__":
    main()
